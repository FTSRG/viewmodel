package hu.bme.mit.inf.viewmodel.runtime.queries.logicmodel

import "http://inf.mit.bme.hu/emf/2017/LogicModel"
// Must not use "http://www.eclipse.org/emf/2002/Ecore",
// because Xcore already loads Ecore.ecore into the ResourceSet with a platform resource URI.
import "platform:/resource/org.eclipse.emf.ecore/model/Ecore.ecore"

pattern concreteRelation(LeftRep : Cluster, RightRep : Cluster, Rel : EStructuralFeature) {
	find strongClusterRelation(LeftRep, RightRep, Rel);
	N == count find clusterRelation(LeftRep, _, Rel);
	EStructuralFeature.upperBound(Rel, Bound);
	check(Bound < 0 || Bound >= 1 || N <= 1);
	find strongRelationOppositeAllowed(RightRep, Rel);
	find strongRelationContainmentAllowed(RightRep, Rel);
}

private pattern strongRelationOppositeAllowed(RightRep : Cluster, Rel : EStructuralFeature) {
	find strongClusterRelation(_, RightRep, Rel);
	neg find hasEOpposite(Rel);
} or {
	find strongClusterRelation(_, RightRep, Rel);
	neg find constantEObjectConstraint(RightRep, _);
	neg find constantJavaObjectConstraint(RightRep, _);
	N == count find clusterRelation(_, RightRep, Rel);
	EReference.eOpposite.upperBound(Rel, Bound);
	check(Bound < 0 || Bound >= 1 || N <= 1);
}

private pattern strongRelationContainmentAllowed(RightRep : Cluster, Rel : EStructuralFeature) {
	find strongClusterRelation(_, RightRep, Rel);
	neg find isContainment(Rel);
} or {
	find strongClusterRelation(_, RightRep, Rel);
	1 == count find containmentClusterRelation(_, RightRep, _);
}

private pattern containmentClusterRelation(LeftRep : Cluster, RightRep : Cluster, Rel : EReference) {
	find strongClusterRelation(LeftRep, RightRep, Rel);
	find isContainment(Rel);
}

pattern concreteVariable(Rep : Cluster, Type : EClass) {
	neg find constantEObjectConstraint(Rep, _);
	neg find javaObjectConstantValue(Rep, _);
	find concreteClusterType(Rep, Type);
}

pattern eObjectConstantValue(Rep : Cluster, Value : EObject) {
	neg find constantJavaObjectConstraint(Rep, _);
	1 == count find constantEObject(Rep, _);
	find constantEObjectConstraint(Rep, Const);
	neg find typeConstraintViolatingConstant(Rep, Const);
	ConstantEObjectConstraint.value(Const, Value);
}

pattern javaObjectConstantValue(Rep : Cluster, Value : java Object) {
	neg find requiredClusterType(Rep, _);
	neg find constantEObjectConstraint(Rep, _);
	1 == count find constantJavaObject(Rep, _);
	find constantJavaObjectConstraint(Rep, Const);
	neg find javaTypeConstraintViolatingConstant(Rep, Const);
	ConstantJavaObjectConstraint.value(Const, Value);
}

private pattern typeConstraintViolatingConstant(Rep : Cluster, Const : ConstantEObjectConstraint) {
	find constantEObjectConstraint(Rep, Const);
	ConstantEObjectConstraint.valueType(Const, Type);
	find requiredClusterType(Rep, SuperType);
	neg find conformsTo(SuperType, Type);
}

private pattern javaTypeConstraintViolatingConstant(Rep : Cluster, Const : ConstantJavaObjectConstraint) {
	find constantJavaObjectConstraint(Rep, Const);
	ConstantJavaObjectConstraint.valueType(Const, JavaType);
	find requiredJavaClusterType(Rep, RequiredType);
	// HACK Evil casting to work around code generation issue in requiredJavaClusterType/2.
	check(!(RequiredType as Class<?>).isAssignableFrom(JavaType));
}

private pattern constantEObject(Rep : Cluster, Value : EObject) {
	find constantEObjectConstraint(Rep, Const);
	ConstantEObjectConstraint.value(Const, Value);
}

private pattern constantEObjectConstraint(Rep : Cluster, Const : ConstantEObjectConstraint) {
	find representedVariable(Rep, Var);
	ConstantEObjectConstraint.variable(Const, Var);
}

private pattern constantJavaObject(Rep : Cluster, Value : java Object) {
	find constantJavaObjectConstraint(Rep, Const);
	ConstantJavaObjectConstraint.value(Const, Value);
}

private pattern constantJavaObjectConstraint(Rep : Cluster, Const : ConstantJavaObjectConstraint) {
	find representedVariable(Rep, Var);
	ConstantJavaObjectConstraint.variable(Const, Var);
}
